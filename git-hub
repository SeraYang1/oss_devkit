#!/usr/bin/env python
import subprocess
import github
import yaml
import click
import sys
import textwrap
import json
import toml
import app
import plot_pr
import os
from datetime import datetime
from urllib.request import urlopen, Request
from os.path import join as pjoin
import ansi


def login():
    """Retrieves the user's remote.
    For example consider running 'git remote -v' and getting back:
        origin  git@github.com:test_user/test_repo.git (fetch)
        origin git@github.com:test_user/test_repo.git (push)

    Returns
    -------
    username : string
        username of the remote, i.e. test_user
    repo : string
        origin repository of the github user, i.e. test_repo
    remotes : string
        Git remotes: the output of 'git remote -v'

    """
    process = subprocess.Popen(["git", "remote", "-v"], stdout=subprocess.PIPE)
    remotes = str(process.stdout.read())
    url = remotes.split(" ", 1)[0]
    arguments = url.split(".com")[1]
    arguments = arguments[1:]
    arguments = arguments.split(".git")[0]
    username, repo = arguments.split("/")
    return (username, repo, remotes)


def get_token():
    """Retrieve token from configuration file.

    Returns
    -------
    token : string
        a number corresponding to user's authentication
    """
    token = ""
    if os.path.isfile(os.path.expanduser("~/.config/git-hub.yaml")):
        with open(os.path.expanduser("~/.config/git-hub.yaml")) as stream:
            yaml_file = str(yaml.load(stream))
            token = yaml_file.split("=")[1].strip()
    else:
        token = os.environ['GITHUB_TOKEN']

    if (token is not ""):
        return token
    else:
        print(textwrap.dedent("""\
            No authentication token specified in: ~/.config/git-hub.yaml

            Please see

              https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/

            for instruction on obtaining a token. Then update the configuration
            file as follows:

              token = abc123
        """))
        sys.exit(1)

def pr(num):
    """Pulls down and checkout the branch of the pr.

    This will run the following commands in the terminal:
    "git remote add user git@github.com:user/repo",
    "git fetch user",
    "git checkout -b pr/num user/branch"

    Parameters
    ----------
    num : integer
        The number of the pull request.
    """
    username, repo = login()
    token = get_token()

    try:
        g = github.Github(token)
        pr = g.get_user(username).get_repo(repo).get_pull(num)
        label = pr.head.label
        other_user, branch = label.split(":")
        process = subprocess.Popen(["git", "remote", "-v"], stdout=subprocess.PIPE)
        remotes = str(process.stdout.read())
        remote_name = "\\n" + other_user + "\\t"
        if remote_name not in remotes:
            p = subprocess.Popen(["git", "remote", "add", other_user,
                                  f'git@github.com:{other_user}/{repo}'])
            p.communicate()
        p = subprocess.Popen(["git", "fetch", other_user],
                             stdout=subprocess.PIPE)
        p.stdout.read()
        subprocess.Popen(["git", "checkout", "-b",
                         f'pr/{num}', f'{other_user}/{branch}'])

    except github.BadCredentialsException as e:
        print(e)
        print("The authentification token is not valid.")
        sys.exit(1)

    except github.UnknownObjectException as e:
        print(e)
        print(f'There is no pr with number {num}.')
        sys.exit(1)


def push():
    """Pushes changes back to a branch.

    This will run the following command:
    "git push user pr/num:branch"

    """
    p = subprocess.Popen(["git", "branch"], stdout=subprocess.PIPE)
    pr = str(p.stdout.read())
    pr = pr.split("*", 1)[1].split()[0]
    pr = pr.replace("\\n", "").replace(" ", "").replace("'", "").split("/")[1]
    try:
        path_prs = path_to_toml()
        f = open(path_prs, "r")
        pr_dict = toml.load(f)
    except (OSError, IOError) as e:
        sync()
        push()

    user = pr_dict['open pull requests'][pr]['user']
    branch = pr_dict['open pull requests'][pr]["branch"]
    p = subprocess.Popen(["git", "push", user,
                         f'pr/{pr}:{branch}'], stdout=subprocess.PIPE)
    p.stdout.read()


def path_to_git():
    """Finds path to .git folder
    """
    path_repo = os.path.abspath('.')
    while (os.path.abspath(path_repo) != '/'
           and not os.path.isdir(pjoin(path_repo, '.git'))):
        path_repo = pjoin(path_repo, '..')
    path_git = pjoin(path_repo, ".git")
    return path_git


def path_to_toml():
    """Finds path to pull-requests.toml
    """
    path_git = path_to_git()
    path_github = pjoin(path_git, 'git-hub')
    path_prs = pjoin(path_github, 'pull-requests.toml')
    return path_prs


def find_in_dictionary(pr_id, pr_data):
    """Fetches all the information on a certain PR

    Parameters
    ----------
    pr_id : integer
        the pull request's number
    pr_data : dictionary
        dictionary of open or closed PRs to find pr_id in
    """
    if(pr_data is not None):
        for pr_nr in pr_data:
            if(pr_nr == str(pr_id)):
                return pr_nr, pr_data[pr_nr]
    return None, None


def get_info(pr_data):
    """Fetches all the information on a certain PR

    Parameters
    ----------
    pr_data : integer
        number of PR to fetch information from
    """

    try:
        path_prs = path_to_toml()
        f = open(path_prs, "r")
        pr_dict = toml.load(f)
        open_dict = pr_dict['open pull requests']
        closed_dict = pr_dict['closed pull requests']
    except (OSError, IOError) as e:
        sync()
        get_info(pr_data)

    open_PR = "O"
    key, pr_dictionary = find_in_dictionary(pr_data, open_dict)
    if(pr_dictionary is None):
        open_PR = "C"
        key, pr_dictionary = find_in_dictionary(pr_data, closed_dict)
    if(pr_dictionary is None):
        click.echo(f"Could not find PR #{pr_data}."
                   "Run 'git hub sync' and try again.")
    else:
        reviewers = pr_dictionary.get('reviewers', 'None')
        assignee = pr_dictionary.get('assignee', 'None')
        milestone = pr_dictionary.get('milestone', 'None')
        labels = pr_dictionary.get('labels', 'None')
        branch = pr_dictionary.get('branch', 'None')
        commits = pr_dictionary.get('commits', 'None')
        most_recent_comment = pr_dictionary.get('most_recent_comment', 'None')
        comment_count = pr_dictionary.get('comment_count', 'None')
        created_at = pr_dictionary.get('created_at', 'None')
        updated_at = pr_dictionary.get('updated_at', 'None')
        click.echo(f'{key} {ansi.GREEN} {open_PR} {ansi.CLOSE}'
                   f'{pr_dictionary["user"]}/{pr_dictionary["branch"]}'
                   f' {pr_dictionary["comment"]}')
        click.echo(f'-Created at: {created_at}  -Updated at: {updated_at}')
        click.echo(f'-Commits: {commits}  -Comment count: {comment_count}'
                   f'-Most recent comment: {most_recent_comment}')
        click.echo(f'-Labels: {labels}  -Reviewers: {reviewers}'
                   f'-Branch: {branch}  -Assignees: {assignee}'
                   f'-Milestones: {milestone}')


def parse_time(time):
    """
    Converts time into python datetime object

    Parameters
    ----------
    time : String
        Time that git-hub gives
    """
    date = time.split('T')[0]
    time = time.split('T')[1][:-1]
    year, date = date.split('-', 1)
    month, date = date.split('-', 1)
    day = date
    hour, time = time.split(':', 1)
    minute, time = time.split(':', 1)
    second = time
    d = datetime(int(year), int(month),
                 int(day), int(hour), int(minute), int(second))
    return d


def print_in_order(dict, increasing=False):
    """
    Prints items in q sorted by order given by sort

    Parameters
    ----------
    Q : PriorityQueue
        items to be sorted, currently in increasing order
    inreasing : boolean
        tells if the user wants dates in order of most recent first
    """
    if(increasing):
        sorted_list = sorted(dict)
        for x in sorted_list:
            click.echo(f"{dict[x]} : {x[:10]}")
    else:
        sorted_list = sorted(dict, reverse=True)
        for x in sorted_list:
            click.echo(f"{dict[x]} : {x[:10]}")


def find_match(open_or_closed, list_of_dictionaries,
               keyword, user, comment, number, branch, label):
    """Helper function that finds all matches in the
       given dictionary that fits the specified parameters.

    Parameters
    ----------
    open_or_closed : boolean
        Whether looking in closed PR or open PR
    list_of_dictionaries : dictionary
        pull-requests.toml information mapping PR number to info
    keyword : string
        Searches if any part of user, branch, comment, or number match
    user : string
        Search by PR username
    comment : string
        Search by PR comment
    number : string
        Search by PR number
    branch : string
        Search by PR branch

    Returns
    ----------
    appeared_before : boolean
        Whether the search match is the first match
    all_prs : list
        All the prs that match the criteria
    """
    appeared_before = False
    all_prs = {}
    for dictionary in list_of_dictionaries:
        for sub_keys in list(dictionary.keys()):
            sub_dict = dictionary[sub_keys]
            if keyword:
                concate = " ".join(sub_dict.values())
                if keyword.upper() in concate.upper():
                    appeared_before = True
                    if(open_or_closed):
                        all_prs[sub_dict['modified']] = (
                            f'{sub_keys} '
                            f'{ansi.GREEN} "O" {ansi.CLOSE}'
                            f'{sub_dict["user"]}/{sub_dict["branch"]}'
                            f' {sub_dict["comment"]}')
                    else:
                        all_prs[sub_dict['modified']] = (
                            f'{sub_keys} {ansi.RED} "C"'
                            f'{ansi.CLOSE} {sub_dict["user"]}/'
                            f'{sub_dict["branch"]} {sub_dict["comment"]}')
            else:
                temp_user = sub_dict['user']
                temp_branch = sub_dict["branch"]
                temp_comment = sub_dict["comment"]
                temp_label = sub_dict["labels"]
                if (label.upper() in temp_label.upper() and comment.upper()
                        in temp_comment.upper() and user.upper()
                        in temp_user.upper() and branch.upper()
                        in temp_branch.upper()):
                    appeared_before = True
                    if(open_or_closed):
                        all_prs[sub_dict['modified']] = (
                            f'{sub_keys} {ansi.GREEN} "O"'
                            f'{ansi.CLOSE} {sub_dict["user"]}/'
                            f'{sub_dict["branch"]} {sub_dict["comment"]}')
                    else:
                        all_prs[sub_dict['modified']] = (
                            f'{sub_keys} {ansi.RED} "C" '
                            f'{ansi.CLOSE} {sub_dict["user"]}/'
                            f'{sub_dict["branch"]} {sub_dict["comment"]}')
    return appeared_before, all_prs


def search(keyword, user, comment, number,
           branch, opened_or_closed, label, sort):
    """Searches open and closed pull request comments for specified keyword.

    Opens pull-requests.toml file in .git folder to fetch pull requests.

    Parameters
    ----------
    keyword : string
        Searches if any part of user, branch, comment, or number match
    user : string
        Search by PR username
    comment : string
        Search by PR comment
    number : string
        Search by PR number
    branch : string
        Search by PR branch
    """
    try:
        open_prs = False
        closed_prs = False
        path_prs = path_to_toml()
        f = open(path_prs, "r")
        pr_dict = toml.load(f)
    except (OSError, IOError) as e:
        sync()
        search(keyword, user, comment, number,
               branch,  opened_or_closed, label, sort)

    open_dict = pr_dict['open pull requests']
    closed_dict = pr_dict['closed pull requests']
    if(not opened_or_closed or opened_or_closed.lower() == 'open'):
        open_prs, q = find_match(True, open_dict, keyword,
                                 user, comment, number, branch, label)
        print_in_order(q, sort.startswith('i'))
    if(not opened_or_closed or opened_or_closed.lower() == 'closed'):
        closed_prs, q = find_match(False, closed_dict, keyword,
                                   user, comment, number, branch, label)
        print_in_order(q, sort.startswith('i'))
    if not open_prs and not closed_prs:
        click.echo(f"Could not find in pull requests. Update your "
                   f"pull requests with 'git hub sync' and try again.")


def find_pr_info(username, repo, pr, token, open_or_closed):
    """Helper function that finds all the information we want to record from the
    pull requests from the API and converts it to toml format syntax

    Parameters
    ----------
    username : string
        username created of PR
    repo : string
        repo user created PR from
    pr : object
        PR dictionary
    token : string
        authentication token for user
    open_or_closed : string
        if the PR is open or closed
    """
    to_write = ""
    url = f'https://api.github.com/repos/{username}/{repo}/pulls/{pr.number}'
    request = Request(url)
    request.add_header('Authorization', 'token %s' % token)
    response = urlopen(request)
    response = json.loads(response.read().decode('utf-8'))
    issue_url = response.get('issue_url')
    labels = ""
    issue_request = Request(issue_url)
    issue_response = urlopen(issue_request)
    issue_response = json.loads(issue_response.read().decode('utf-8'))
    labels_dict = issue_response.get('labels')
    comment_url = response.get('comments_url')
    comment_request = Request(comment_url)
    comment_response = urlopen(comment_request)
    comment_dict = json.loads(comment_response.read().decode('utf-8'))

    reviews = [reviewer.get('login') for reviewer in
               list(response.get('requested_reviewers'))]
    assignees = [assignee.get('login')
                 for assignee in list(response.get('assignees'))]
    labels = [label.get('name') for label in list(labels_dict)]
    comment_dates = [c.get('updated_at') for c in list(comment_dict)]
    if(pr.number % 5 == 0):
        print("Syncing PR ", pr.number)
    to_write = f"""
    ['{open_or_closed} pull requests'.{pr.number}]\n
    title = "{repr(response.get('title'))}" \n
    url = "{response.get('html_url')}"\n
    body = "{repr(response.get('body'))}" \n
    user = "{pr.user.login}" \n
    branch = "{response.get('head').get('ref')}" \n
    mergeable = "{pr.mergeable}" \n
    comment = "{repr(pr.title)}" \n
    commits = "{repr(response.get('commits'))}" \n
    modified = "{pr.updated_at}" \n
    created_at = "{response.get('created_at')}" \n
    updated_at = "{response.get('updated_at')}" \n
    closed_at = "{response.get('closed_at')}" \n
    merged_at = "{response.get('merged_at')}" \n
    reviews = {repr(reviews)} \n
    assignees = {assignees} \n
    milestone = "{pr.milestone.title if pr.milestone else ""}"\n
    labels = {labels}\n
    self_comment = "{any([c.get('user').get('login') == username
                    for c in list(comment_dict)])}"\n
    comment_dates = {comment_dates}\n
    most_recent = '{max(comment_dates) if comment_dates  else ""}'\n
    comment_content = {repr([c.get("body") for c in list(comment_dict)])}\n
    comment_count = '{len(list(comment_dict))}'\n
    """
    return textwrap.dedent(to_write)


def find_issue_info(username, repo, issue, token):
    """Helper function that finds all the information
       we want to record from the issues
       from the API and converts it to toml format syntax.

    Parameters
    ----------
    username : string
        username created of PR
    repo : string
        repo user created PR from
    pr : object
        PR dictionary
    token : string
        authentication token for user
    """
    url = (f'https://api.github.com/repos/'
           f'{username}/{repo}/issues/{issue.number}')
    request = Request(url)
    request.add_header('Authorization', 'token %s' % token)
    response = urlopen(request)
    response = json.loads(response.read().decode('utf-8'))
    comment_url = response.get('comments_url')
    comment_request = Request(comment_url)
    comment_response = urlopen(comment_request)
    comment_dict = json.loads(comment_response.read().decode('utf-8'))
    comment_dates = [c.get('updated_at') for c in list(comment_dict)]
    comment_content = [c.get("body") for c in list(comment_dict)]
    to_write = f"""
    ['issues'.{issue.number}]\n
    title = "{response.get('title')}"\n
    url = "{response.get('html_url')}"\n
    number = "{response.get('number')}"\n
    body = '''{repr(response.get('body'))}'''\n
    self_comment = "{any([c.get('user').get('login') == username
                    for c in list(comment_dict)])}"\n
    comment_dates = "{comment_dates}"\n
    most_recent = '{max(comment_dates) if comment_dates  else ""}'\n
    comment_content = {repr(comment_content)}\n
    comment_count = '{len(list(comment_dict))}'\n
    """
    return textwrap.dedent(to_write)


def sync():
    """Updates and saves pull-requests
       in pull-requests.toml in the .git folder.
    """
    username, repo, remotes = login()
    token = get_token()

    try:
        g = github.Github(token)
        path_git = path_to_git()
        path_github = pjoin(path_git, 'git-hub')
        path_prs = path_to_toml()
        if not os.path.isdir(path_github):
            os.makedirs(path_github)
        f = open(path_prs, "w")
        to_write = "['open pull requests']\n"
    except github.BadCredentialsException as e:
        print(e)
        click.echo("The authentification token is not valid.")
        sys.exit(1)

    open_prs = g.get_user(username).get_repo(repo).get_pulls("open")
    for pr in open_prs:
        to_write = to_write + find_pr_info(username, repo, pr, token, "open")
    to_write = to_write[:-1]+'\n'
    to_write = to_write + "['closed pull requests'] \n"
    closed_prs = g.get_user(username).get_repo(repo).get_pulls("closed")
    for pr in closed_prs:
        to_write = to_write + find_pr_info(username, repo, pr, token, "closed")

    issues = g.get_user(username).get_repo(repo).get_issues()
    to_write = to_write + "['issues'] \n"
    for issue in issues:
        if f"pull requests'.{issue.number}" not in to_write:
            to_write = to_write + find_issue_info(username, repo, issue, token)
    toml_string = toml.loads(to_write)
    toml.dump(toml_string, f)


def render():
    try:
        plot_pr.execute()
    except ImportError:
        print(f'Matplotlib not installed, cannot render image. Continuing'
              f'without image.')
    app.main()


def find_path_to_git():
    path_repo = os.path.abspath('.')
    while (os.path.abspath(path_repo) != '/' and
        not os.path.isdir(pjoin(path_repo, '.git'))):
            path_repo = pjoin(path_repo, '..')
    path_git = pjoin(path_repo, ".git")
    return path_git


def find_in_dictionary(pr_num, open_or_closed_dictionary):
    """Fetches all the information on a certain PR

    Parameters
    ----------
    pr_num : integer
        number of PR to fetch information from
    open_or_closed_dictionary : dictionary
        dictionary of open or closed PRs to find number in
    """
    if(open_or_closed_dictionary is None):
        return None, None
    for dictionary in open_or_closed_dictionary:
        for sub_keys in list(dictionary.keys()):
            if(sub_keys == str(pr_num)):
                return sub_keys, dictionary[sub_keys]
    return None, None


def get_info(pr_num):
    """Fetches all the information on a certain PR

    Parameters
    ----------
    pr_num : integer
        number of PR to fetch information from
    """

    try:
        path_git = find_path_to_git()
        path_github = pjoin(path_git, 'git-hub')
        path_prs = pjoin(path_github, 'pull-requests.toml')
        f = open(path_prs, "r")
        pr_dict = toml.load(f)
        open_dict = pr_dict['open pull requests']
        closed_dict = pr_dict['closed pull requests']
    except (OSError, IOError) as e:
        sync()
        get_info(pr_num)

    open_PR = "O"
    key, pr_dictionary = find_in_dictionary(pr_num, open_dict)
    if(pr_dictionary is None):
        open_PR = "C"
        key, pr_dictionary = find_in_dictionary(pr_num, closed_dict)
    if(pr_dictionary is None):
        click.echo(f'Could not find PR #{pr_num}. Run `git hub sync` and try '
                   f'again.')
    else:
        reviewers = "None"
        if(pr_dictionary['reviews'] is not ""):
            reviewers = pr_dictionary['reviews']
        assignee = "None"
        if(pr_dictionary['assignees'] is not ""):
            assignee = pr_dictionary['assignees']
        milestone = "None"
        if(pr_dictionary['milestone'] is not ""):
            milestone = pr_dictionary['milestone']
        labels = "None"
        if(pr_dictionary['labels'] is not ""):
            labels = pr_dictionary['labels']
        created_at = pr_dictionary['created_at'][:10]
        updated = pr_dictionary['modified'][:10]
        comments = pr_dictionary['comment_count']
        if open_PR == 'O':
            click.echo(f'{key} {ansi.GREEN} {open_PR} {ansi.CLOSE} '
                       f'{pr_dictionary["user"]}/{pr_dictionary["branch"]}'
                       f' {pr_dictionary["comment"]}')
        else:
            click.echo(f'{key} {ansi.RED} {open_PR} {ansi.CLOSE} '
                       f'{pr_dictionary["user"]}/{pr_dictionary["branch"]}'
                       f' {pr_dictionary["comment"]}')

        click.echo(f'-Reviewers: {reviewers} \n-Assignees: {assignee} \n'
                   f'-Labels: {labels} \n-Milestones: {milestone} \n-Comment '
                   f'count: {comments} \n-Created at: {created_at} \n-Last '
                   f'modified: {updated}')


def print_in_order(sort, dict):
    """
    Prints items in q sorted by order given by sort

    Parameters
    ----------
    sort : string
        sort in increasing or decreasing order
    q : PriorityQueue
        items to be sorted, currently in increasing order
    """
    if(sort.startswith('i')):
        sorted_list = sorted(dict)
        for x in sorted_list:
            click.echo("{0} : {1}".format(dict[x], x[:10]))
    else:
        sorted_list = sorted(dict, reverse=True)
        for x in sorted_list:
            click.echo("{0} : {1}".format(dict[x], x[:10]))


def find_match(open_or_closed, list_of_dictionaries, keyword, user, comment,
               number, branch, label):
    """Helper function that finds all matches in the given dictionary that fits
    the specified parameters

    Parameters
    ----------
    open_or_closed : boolean
        Whether looking in closed PR or open PR
    dictionary : dictionary
        pull-requests.toml information mapping PR number to info
    keyword : string
        Searches if any part of user, branch, comment, or number match
    user : string
        Search by PR username
    comment : string
        Search by PR comment
    number : string
        Search by PR number
    branch : string
        Search by PR branch
    appeared_before : boolean
        Whether the search match is the first match
    """
    appeared_before = False
    all_prs = {}
    for dictionary in list_of_dictionaries:
        for sub_keys in list(dictionary.keys()):
            sub_dictionary = dictionary[sub_keys]
            if number:
                if number == sub_keys:
                    appeared_before, all_prs = write_output(all_prs,
                                                            open_or_closed,
                                                            sub_keys,
                                                            sub_dictionary)
            elif keyword:
                temp_user = sub_dictionary['user']
                temp_branch = sub_dictionary["branch"]
                temp_comment = sub_dictionary["comment"]
                temp_label = " ".join(sub_dictionary["labels"])
                values = ""
                values += temp_user.upper() + " " + temp_branch.upper() + " "
                values += temp_comment.upper() + " " + temp_label.upper() + " "
                values += sub_keys
                if keyword.upper() in values.upper():
                    appeared_before, all_prs = write_output(all_prs,
                                                            open_or_closed,
                                                            sub_keys,
                                                            sub_dictionary)
            else:
                temp_user = sub_dictionary['user']
                temp_branch = sub_dictionary["branch"]
                temp_comment = sub_dictionary["comment"]
                temp_label = " ".join(sub_dictionary["labels"])
                if (label.upper() in temp_label.upper() and comment.upper() in
                   temp_comment.upper() and user.upper() in temp_user.upper()
                   and branch.upper() in temp_branch.upper()):
                    appeared_before, all_prs = write_output(all_prs,
                                                            open_or_closed,
                                                            sub_keys,
                                                            sub_dictionary)
    return appeared_before, all_prs


def write_output(all_prs, open, num, pr_dict):
    """Helper function that writes output string for find_match

    Parameters
    ----------
    all_prs: dictionary
        Dictionary of return values
    open : boolean
        Tells if the PR is open or closed
    num : integer
        PR number
    pr_dict : dictionary
        Dictionary of PR attributes and values
    """
    if(open):
        all_prs[pr_dict['modified']] = f'{num} {ansi.GREEN} O {ansi.CLOSE} '\
                                       f'{pr_dict["user"]}/'\
                                       f'{pr_dict["branch"]} '\
                                       f'{pr_dict["comment"]}'
    else:
        all_prs[pr_dict['modified']] = f'{num} {ansi.RED} C {ansi.CLOSE} '\
                                       f'{pr_dict["user"]}/'\
                                       f'{pr_dict["branch"]} '\
                                       f'{pr_dict["comment"]}'
    return True, all_prs


def search(keyword, user, comment, number, branch, opened_or_closed, label,
           sort):
    """Searches open and closed pull request comments for specified keyword.

    Opens pull-requests.toml file in .git folder to fetch pull requests.

    Parameters
    ----------
    keyword : string
        Searches if any part of user, branch, comment, or number match
    user : string
        Search by PR username
    comment : string
        Search by PR comment
    number : string
        Search by PR number
    branch : string
        Search by PR branch
    """
    try:
        open_prs = False
        closed_prs = False
        path_git = find_path_to_git()
        path_github = pjoin(path_git, 'git-hub')
        path_prs = pjoin(path_github, 'pull-requests.toml')
        f = open(path_prs, "r")
        pr_dict = toml.load(f)
    except (OSError, IOError) as e:
        sync()
        search(keyword, user, comment, number, branch, status)
    open_dict = pr_dict['open pull requests']
    closed_dict = pr_dict['closed pull requests']
    if(not opened_or_closed or opened_or_closed.lower() == 'open'):
        open_prs, q = find_match(True, open_dict, keyword, user, comment,
                                 number, branch, label)
        print_in_order(sort, q)
    if(not opened_or_closed or opened_or_closed.lower() == 'closed'):
        closed_prs, q = find_match(False, closed_dict, keyword, user, comment,
                                   number, branch, label)
        print_in_order(sort, q)
    if not open_prs and not closed_prs:
        click.echo(f'Could not find in pull requests. Update your pull requests'
                   f' with `git hub sync` and try again.')


def json_to_toml(username, repo, pr, token, open_or_closed):
    """Helper function that finds all the information we want to record from the
    json file.

    Parameters
    ----------
    username : string
        username created of PR
    repo : string
        repo user created PR from
    pr : integer
        PR id number
    token : string
        authentication token for user
    open_or_closed : string
        if the PR is open or closed
    """
    to_write = ""
    url = f'https://api.github.com/repos/{username}/{repo}/pulls/{pr.number}'
    request = Request(url)
    request.add_header('Authorization', 'token %s' % token)
    response = urlopen(request)
    response = json.loads(response.read().decode('utf-8'))
    to_write = to_write + f"['{open_or_closed} pull requests'.{pr.number}]\n"
    to_write = to_write + f'user = "{pr.user.name}" \n'
    to_write = to_write + f'branch = "{response.get("head").get("ref")}" \n'
    to_write = to_write + f'comment = "{pr.title}" \n'
    to_write = to_write + f'modified = "{pr.updated_at}" \n'
    reviewers = ""
    for reviewer in list(response.get('requested_reviewers')):
        reviewers = reviewers + reviewer.get('login')+", "
    to_write = to_write + f'reviewers = "{reviewers[:-2]}" \n'
    assignees = ""
    for assignee in list(response.get('assignees')):
        assignees = assignees + assignee.get('login')+", "
    to_write = to_write + f'assignee = "{assignees[:-2]}" \n'
    if(pr.milestone):
        to_write = to_write + f'milestone = "{pr.milestone.title}" \n'
    else:
        to_write = to_write + 'milestone = "" \n'
    issue_url = response.get('issue_url')
    labels = ""
    issue_request = Request(issue_url)
    issue_response = urlopen(issue_request)
    issue_response = json.loads(issue_response.read().decode('utf-8'))
    labels_dict = issue_response.get('labels')
    for label in list(labels_dict):
        labels = labels + label.get('name')+", "
    to_write = to_write + f'labels = "{labels[:-2]}" \n'
    return to_write


def checkout(url):
    num = url.split("/")[-1]
    user = url.split("/")[-4]
    repo = url.split("/")[-3]
    token = get_token()
    url = f'https://api.github.com/repos/{user}/{repo}/pulls/{num}'
    request = Request(url)
    request.add_header('Authorization', 'token %s' % token)
    response = urlopen(request)
    response = json.loads(response.read().decode('utf-8'))
    branch = response.get('head').get('ref')

    p = subprocess.run(["git", "branch"], stdout=subprocess.PIPE)
    remotes = str(p.stdout.decode("utf-8").strip('\n'))
    if "PR_{num}" not in remotes:
        p = subprocess.run(["git", "fetch", "origin",
                            f'refs/pull/{num}/head:PR_{num}'])
        p = subprocess.run(["git", "branch",
                            f'--set-upstream-to=upstream/{branch}',
                            f'PR_{num}'])
    else:
        p = subprocess.run(["git", "checkout", f'PR_{num}'])
        p = subprocess.run(["git", "pull"])


def sync():
    """Updates and saves pull-requests in pull-requests.toml in the .git folder.
    """
    username, repo, remotes = login()
    token = get_token()
    print("Syncing information.... this could take a while")
    try:
        g = github.Github(token)
        path_git = find_path_to_git()
        path_github = pjoin(path_git, 'git-hub')
        path_prs = pjoin(path_github, 'pull-requests.toml')
        if not os.path.isdir(path_github):
            os.makedirs(path_github)
        if not os.path.isfile(path_prs):
            f = open(path_prs,"w+")
        f = open(path_prs, "w+")
        to_write = "[['open pull requests']]\n"
    except github.BadCredentialsException as e:
        print(e)
        print("The authentification token is not valid.")
        sys.exit(1)
    print("Syncing OPEN pull requests")
    open_prs = g.get_user(username).get_repo(repo).get_pulls("open")
    for pr in open_prs:
        to_write = to_write + find_pr_info(username, repo, pr, token, "open")
    to_write = to_write[:-1]+'\n'

    print("Syncing CLOSED pull requests")
    to_write = to_write + "[['closed pull requests']] \n"
    closed_prs = g.get_user(username).get_repo(repo).get_pulls("closed")
    for pr in closed_prs:
        to_write = to_write + find_pr_info(username, repo, pr, token, "closed")

    issues = g.get_user(username).get_repo(repo).get_issues()
    to_write = to_write + "['issues'] \n"
    for issue in issues:
        if f"pull requests'.{issue.number}" not in to_write:
            to_write = to_write + find_issue_info(username, repo, issue, token)
    toml_string = toml.loads(to_write)
    toml.dump(toml_string, f)


@click.group()
def cli():
    pass


@cli.command()
@click.argument("command", default="")
@click.argument("args", nargs=-1)
@click.option('--opened', '-o', default="",
              help="search by open or closed PRs")
@click.option('--user', '-u', default="", help="search by user")
@click.option('--branch', '-b', default="", help="search by branch")
@click.option('--comment', '-c', default="", help="search by comment")
@click.option('--number', '-n', default="", help="search by PR number")
@click.option('--sort', '-s', default="",
              help="sort PRs by increasing or decreasing date")
@click.option('--label', '-l', default="", help="search PR by label")
def hub(command, args, user, comment, number, branch, sort, opened, label):
    if command == "pr":
        pr_num = int(args[0])
        pr(pr_num)

    elif command == "push":
        push()

    elif command == "search":
        if(not args):
            search(None, user, comment, number, branch, opened, label, sort)
        else:
            search(" ".join(args), user, comment,
                   number, branch, opened, label, sort)
    elif command == "sync":
        sync()

    elif command == "info":
        if not args:
            print("Please specify a PR number (ex. `git hub info 2`)")
            return
        pr_num = int(args[0])
        get_info(pr_num)

    elif command == "render":
        render()

    elif command == "checkout":
        checkout(str(args[0]))

    else:
        print("invalid command")
        sys.exit(1)


if __name__ == "__main__":
    hub()
